syntax = "proto3";

package protean_proto.sim;

option optimize_for = LITE_RUNTIME;

import "onnx-ml.proto";
import "protean.proto";

// Considering add Lamport clock for tracing, but getting this working first.

/* --------------------- Services --------------------- */

service WorkerNode {
    // Lifecycle & Configuration
    /// Set worker-wide simulation configuration
    rpc SetConfig(ProteanConfigProto) returns (Ack) {}

    /// Sets Bootstrap Servers
    rpc SetBootstrapServers(BootstrapPeerRequest) returns (Ack) {}

    /// Create new peers (for bootstrapping)
    rpc CreatePeers(CreatePeersRequest) returns (Ack) {}

    /// Delete specific peers by UUID
    rpc DeletePeers(DeletePeersRequest) returns (Ack) {}

    /// Delete and create new peers
    rpc ChurnPeers(ChurnPeersRequest) returns (Ack) {}

    /// Start a Churn Pattern
    rpc DriftPeer(DriftPeerRequest) returns (Ack) {}

    // Query Execution
    /// Execute a query from a specific peer
    rpc ExecuteQuery(QueryRequest) returns (QueryResponse) {}

    // State Management
    /// Get snapshot of current network state (all or filtered peers)
    rpc GetSnapshot(SnapshotRequest) returns (NetworkSnapshot) {}

    /// Load network state from snapshot
    rpc LoadSnapshot(NetworkSnapshot) returns (Ack) {}

    /// Inform about another worker that can be sent messages
    rpc RegisterWorker(WorkerInfo) returns (Ack) {}

    /// Route a protocol message to a peer on this worker
    rpc RouteMessage(RouteMessageRequest) returns (Ack) {}
}

service CoordinatorNode {
    // Worker Registration & Health
    /// Worker registers with coordinator
    rpc RegisterWorker(WorkerInfo) returns (Ack) {}

    rpc ForwardEvent(ProteanEventProto) returns (Ack) {}
}


/* --------------------- Common Messages --------------------- */

message Ack {
}

/* --------------------- Peer Lifecycle Messages --------------------- */
/// Config for peer creation
message ProteanConfigProto {
    uint64 timeout_sec = 1;
    uint32 max_concurrent_queries = 2;
    protean_proto.SnvConfigProto snv_config = 3;
}

/// Bootstrap peer information for peer creation
message BootstrapPeerRequest {
    repeated protean_proto.PeerProto bs_server = 1;
}

/// Request to create multiple peers
message CreatePeersRequest {
    repeated protean_proto.PeerProto peers = 1;
}

/// Request to delete specific peers
message DeletePeersRequest {
    repeated bytes uuids = 1;
}

message ChurnPeersRequest {
    CreatePeersRequest create = 1;
    DeletePeersRequest delete = 2;
}

message DriftPeerProto {
    bytes uuid = 1;
    onnx.TensorProto target_embedding = 2;
    uint64 drift_steps = 3;       // Number of drift steps
    uint64 duration_per_step_sec = 4;  // Interval between drift updates in milliseconds
}

message DriftPeerRequest {
    repeated DriftPeerProto drifts = 1;
}

/* --------------------- Query Messages --------------------- */

/// Request to execute a query from a specific peer
message QueryRequest {
    bytes source_peer_uuid = 1;             // UUID of peer executing the query
    onnx.TensorProto query_embedding = 2;   // Query point in embedding space
    uint32 k = 3;                            // Number of neighbors to find
    protean_proto.QueryConfigProto config = 4;  // Query execution config
}

/// Response containing query UUID
message QueryResponse {
    bytes query_uuid = 1;  // Unique query identifier
}

/* --------------------- Snapshot Messages --------------------- */

/// Request for network snapshot
message SnapshotRequest {
    repeated bytes peer_uuids = 1;  // Specific peers to snapshot (empty = all)
    string name = 2;  // Name of the snapshot
}

/// Snapshot of a single SNV
message SnvSnapshotProto {
    uint32 total_peers = 1;
    uint32 routable_peers = 2;
    uint32 suspect_peers = 3;
    uint32 pending_pings = 4;
    uint32 inflight_pings = 5;
    uint32 dynamism = 6;
}
/// Complete network snapshot
message NetworkSnapshot {
    string worker_id = 2;      // Worker that generated this snapshot
    repeated protean_proto.SparseNeighborViewProto peer_snapshots = 3;
    repeated bytes peer_uuids = 4;  // Uuids of the peers in the snapshot
    repeated SnvSnapshotProto snv_snapshots = 5;  // SNV snapshots of the peers
}

/* --------------------- Worker Registration Messages --------------------- */

/// Worker information for registration
/// Peers dont need to know there centroid
message WorkerInfo {
    string address = 1; // gRPC address of worker (host:port)
}

/* --------------------- Message Routing Messages --------------------- */

/// Request to route a protocol message to a peer
message RouteMessageRequest {
    bytes destination_uuid = 1;                      // UUID of destination peer
    protean_proto.ProteanMessageProto message = 2;   // Protocol message to route
}

/* --------------------- Event Streaming Messages --------------------- */

/// Protean event types that can be streamed
enum ProteanEventType {
    STATE_CHANGED = 0;
    QUERY_COMPLETED = 1;
    BOOTSTRAP_CONVERGING_COMPLETED = 2;
    BOOTSTRAP_COMPLETED = 3;
}

/// Event: Peer state transition
message StateChangedEvent {
    bytes peer_uuid = 1;
    string from_state = 2;
    string to_state = 3;
}

/// Event: Query completed with results
message QueryCompletedEvent {
    bytes peer_uuid = 1;
    bytes query_uuid = 2;
    repeated protean_proto.QueryCandidateProto candidates = 3;
    uint32 hops = 4;
}

/// Event: Bootstrap converging phase completed
message BootstrapConvergingCompletedEvent {
    bytes peer_uuid = 1;
}

/// Event: Bootstrap fully completed
message BootstrapCompletedEvent {
    bytes peer_uuid = 1;
}

/// Unified event message
message ProteanEventProto {
    ProteanEventType event_type = 1;

    oneof event {
        StateChangedEvent state_changed = 4;
        QueryCompletedEvent query_completed = 5;
        BootstrapConvergingCompletedEvent bootstrap_converging_completed = 6;
        BootstrapCompletedEvent bootstrap_completed = 7;
    }
}